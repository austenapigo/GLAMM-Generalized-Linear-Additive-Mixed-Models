---
title: "GLM Tutorial"
author: "Ana Miller-ter Kuile and Tatum Katz"
date: "7/21/2020"
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, out.width = "100%")
```

Some useful formatting and visualization packages for this R Markdown:

```{r, warning = FALSE}
library(ggplot2) #plotting
library(tidyverse) #data tidying power
library(gt) #tables
library(here)
```

# Learning goals

1. See and understand the **math of GLMs**
 
2. Know that different kinds of ecological data require different **GLM distributions** (with a nifty table as a resource)
 
3. Know how to **fit a GLM in R** and diagnose how well data fit the selected model distribution
 
4. Feel less intimidated by statistics! Specifically, remember: there are **multiple ways to approach statistics** and all of them are a little wrong, statistics is a tool to **bolster ecological questions**, and as long as you are **consistent** and **transparent** about your process (accessible data and code), you'll be fine

# {.tabset}

# A. GLM Math 

## Part A. Foundations

**Largely adapted from Dr. Wendy Meiring's PSTAT220B course**



### 1. Motivation for extending the Linear Regression Model

Key assumptions in linear models are:  
1. linear dependence of the Y on unkown parameters  
2. additive, random error  
3. errors are Gaussian (normal)  
4. specific mean-variance relationship (Gaussian)  

When do these assumptions break down? Proportion data, count data - i.e. MANY common ecological systems.

The "first step" of extending the linear model to be more flexible is to move to *generalized linear models*.



### 2. What IS a GLM?

All generalized linear models rely on the *natural exponential family of distributions*. Gaussian, Binomial, and Poisson distributions are special cases of the exponential family which assumes a general density function form for the Y:

$$ f(y_i | \theta_i, \phi) = exp \left\{ \frac{y\theta_i - b(\theta_i)}{a_i(\phi)} + c(y_i, \phi) \right\} $$

where $\theta$ is the **canonical parameter** and $\phi$ is the **dispersion parameter**, $i$ ranges from $1,...,n$, and $n$ is your sample size. *Importantly, note which functions and parameters are specific to each observation, and which are true over the whole distribution*. This is some of where the GLM flexibility comes in!

You can think of the **canonical parameter** like a weird, flexible, GLM version of the Gaussian mean, and the **dispersion parameter** like a weird, flexible, GLM version of the Gaussian variance.

All members of the exponential family of distributions' PDFs (probability density functions) can be re-written in the above form. In the Gaussian special case, $\theta_i$ is the mean and $\phi$ is the variance.

A GLM has three components; the chosen distribution is just one of them!

1. **Random component**: specifies the distribution of the response variables $Y_i$ for likelihood computation. In GLM, the distributions must be from the exponential family, and the $Y_i$'s are assumed independent with $E(Y_i | x_i) = \mu_i$ for the explanatory variables $x_i$.

2. **Systematic component**: specifies the linear function of $\beta_p$'s that is a function of the explanatory variables. This is the traditional "right hand side" of the equation of a linear model.

3. **Link function**: specifies how the **mean of the random component** *relates* to the **systematic component**. You can think of this like a  transformation which puts the right hand side of the equation on the same scale as the $Y_i$'s. It is important to note however that the link function $g(.)$ operates on the **mean** $\mu_i$, NOT the response $Y_i$.

Here is how you can write the Gaussian linear model in GLM form:  

1. **Random component**

    $$Y_i \stackrel{independent}{\sim} N(\mu_i, \sigma^2)$$
2. **Systematic component**

    $$\eta_i = \sum^{p-1}_{j=0} \beta_jx_{ij}$$
3. **Link function**

    $$g(\mu_i) = \eta_i \texttt{, where g(.) is the identity function.}$$



### 3. Estimating and comparing GLMs



#### A. Solving for $\beta$'s

Remember how we can have a different function $a_i(\phi)$ for each observation? $a_i(\phi)$ typically has one of two forms:

1. Constant dispersion: $a_i(\phi)$ is independent of $i$, and we give equal weight to each observation.  
2. Unequal weights: $a_i(\phi) = \frac{\phi}{w_i}$, where $w_i$ is unknown. This weights each observation differently, in terms of how much each observation influences estimation of the $\beta$s.

Following, GLM's can have weird mean-variance relationships. In the Gaussian, the mean and variance are independent, but in many GLMs they depend on one another (think Poisson, for which both the mean and the variance is $\lambda$). Therefore, we cannot analytically solve for the traditional MLE, WLS, OLS estimations. The problem is that we wind up with a non-linear (self-referential) system of equations that cannot be solved analytically!

INSTEAD, we estimate the $\beta$s numerically using **iteration**. Remember the **Newton-Raphson algorithm**? This is (basically) what glm() and most other functions which estimate the $\beta$s use, and this is how you can solve for your $\beta$s by hand (but extremely not recommended, talk to Tatum if you want references).

<center>
![](https://i.stack.imgur.com/WaRxk.gif){width=50%}
</center>

If you ever got some warning message like "algorithm did not converge" after trying to run a glm() etc., that means that it wasn't able to converge on a single estimate for your $\beta$s, or even any estimate at all! The NRA isn't the best, or the fastest, or the most reliable approach, even, but it usually works. You can use other methods if you like, but that is an entirely different discussion.



#### B. Model selection for GLMs

Consider two extreme models:

1. **Null model**: $\mu$ is a constant, i.e. $Y$ is predicted only by an intercept. Any variations in the observations are due to the random component alone. Usually, this is far too simple.  
2. **Saturated model**: the systematic component has $n$ parameters ($n$ is still the number of observations!). All variations in the observations are captured by the systematic component. Because this model completely reconstructs the data, it isn't informative or useful.

To compare models against one another, you can use the **deviance**, $D_M$. This can be simply calculated with many R functions.

In practice, comparing nested models is simple. Let's develop a formal hypothesis test! 
To test if a model $M$ with $p$ parameters can be reduced to a sub-model $M_0$ with $q < p$ parameters, we can use the likelihood ratio statistic:

$$\frac{D_{M_0} - D_M}{\phi} \sim X^2_{p-q}  \texttt{ if } H_0 \texttt{: model }M_0\texttt{ is true}$$
But, this only works when $\phi$ is known and fixed, such as in the Poisson or Binomial. These hypotheses can be stacked together to create an *Analysis of Deviance* table (Anode???).

We can also still use AIC and BIC (nested or otherwise), and instead of two-times the log-likelihood, you can just sub out the deviance!

If $\phi$ is unknown, we can estimate it, and then compare models using **an approximate F test** instead:

$$ \frac{D_{M_0} - D_M}{\hat{\phi}(p-q)} \sim F_{(p-q),(n-p)}  \texttt{ if } H_0 \texttt{: model }M_0\texttt{ is true} $$


#### C. Residuals in GLM world

There are two types of departures from a specified GLM:

1. Systematic departure: assumptions about any one of the three components can be wrong (could have chosen the wrong distribution, data are correlated, missing important covariates, or choosing the wrong link function), or you have over-dispersion (see next topic).  
2. Isolated departure: you got outliers, my dude

Residual plots do a great job of finding model issues in linear regression world, but are more iffy in GLM world...still, they are the best we often have.

There are MANY types of residuals for GLM, where in LM you only have the one type. Here are a few important ones, all of which can be computed using R functions:

1. **Response residuals**: $y_i - \hat{\mu_i}$. These are *not useful* for non-Gaussian data since they have different variances!!!  
2. **Partial residuals**: $(y_i - \hat{\mu_i})g'(\hat{\mu_i}) + \hat{\beta_j}x_{ij}$. For each fixed $j$, the plot of these residuals vs. $x_{ij}$ should be a line if the model is correct. A non-linear pattern suggests a higher order term or transformation.  
3. **Deviance residuals**: $\texttt{sign}(y_i - \hat{\mu_i})\sqrt{d_i}$. Commonly used for diagnostics.  
4. **Pearson residuals**: $\frac{y_i - \hat{\mu_i}}{\sqrt{V(\hat{\mu_i})}}$ where $V(\hat{\mu_i})$ is the variance function for your chosen distribution. These are the response residuals scaled by the square root of the variance function.

In the Gaussian case, all of the above residuals are identical to the response residuals!

As with LM, we can also calculate leverage and influence for each point by simply extending the LM equations.

To check for an **isolated depature**, look for high values for any of the residuals, or high leverage of influence values.

To check for a **systematic departure**, you may make plots of the **residuals vs. predictions** (should have mean zero and constant range; curvature arises from anything from wrong choice of link or systematic component; *do not use for binary data*, since it is uninformative), the **residuals vs. covariates** (systematic trend may indicate wrong choice of link and/or missing covariates), or the **partial residuals vs. covariates** (to check scale; the null pattern is approx. a straight line).



#### D. Under- and over-dispersion

A sign things in your model, somewhere, somehow, have gone wrong:

1. **Over-dispersion**: more common of the two, occurs when the variance of the response variable exceeds the nomial value, i.e., $Var(Y) > a(\phi)b''(\theta)$.    

2. **Under-dispersion**: far less common, when the variance of the response variable falls short of the nomial value, i.e., $Var(Y) < a(\phi)b''(\theta)$.

These definitions come from the *moment-generating functions*; you can easily find what the variance should be for any distribution by checking Wikipedia for your distribution and finding the Variance!

A basic approach is to compare your estimated $\phi$ value with the nomial values (which are 1 for Binomial and Poisson). Large deviations are bad. Use this with ~extreme caution~.

**Clustering** is a common cause of over-dispersion. This can happen easily in ecological studies; let's say you sample 10 salamanders from each of 10 ponds. Then you have clustering!

If you do have over-dispersion, you can often model the extra variation by converting Binomial models to Beta-Binomial models and converting Poisson models to Negative-Binomial models, or by moving on to **generalized linear mixed effects models**. You could also move to **quasi-likelihood** models, but these ignore the underlying mechanism and so might be useless for many ecology problems.



#### E. Poisson Rate Models - fishing example

Suppose $Y_i$ is the number of fish caught by a single trawl $i$, which catches the fish in a volume $vol_i$ of water. Different trawls can pass their nets through different volumes of water. We want to use the collected data to estimate the expected "rate" of fish ber unit of water volume, i.e., we want to find $E \left[ \frac{Y_i}{vol_i} \right]$.

This is a common ecological problem - the idea of search effort!

Using some algebra, we can identify a workable model:

Suppose $Y_i \stackrel{independent}{\sim} Poisson(\mu_i)$, so that $E[Y_i] = \mu_i$.

Then, $ln \left( \frac{E[Y_i]}{vol_i} \right) = ln \left( \frac{\mu_i}{vol_i} \right) = ln(\mu_i) - ln(vol_i)$

To turn it into a model now, $ln \left( \frac{\mu_i}{vol_i} \right) = \underline{x}^T_i\underline{\beta}$.

Based on the above, this is equivalent to modeling $ln(\mu_i) = ln(vol_i) + \underline{x}^T_i\underline{\beta}$! You can include the $ln(vol_i)$ term in your glm() using offset().

# B. Common Distributions 

There are lots of different data distributions for GLMs for ecological data. The Zuur book has a great introduction to many of these and the [Kyle Edwards notes](https://sites.google.com/site/kyleedwardsresearch/lecture-notes?authuser=0) (Lectures 6-13) have great succinct explanations and worked examples. Many of these I (Ana) don't actually use but there are a few that are really common in ecology which I use all the time. 

You can find the model families for a given GLM-calling function in R by assessing the `family` object for that function. I usually get there by typing `?glm` or `?glmmTMB` and then selecting either the `family` or the `family_glmmTMB` links from those help pages when they pop up.

We compiled a list of common GLM families, what kinds of data you might fit with them, packages that have that model family, some extra juicy math for each family, and where you might find more information on each of them in Kyle Edwards' notes, or on the interwebs. You can find complementary information on page 205 of the Zuur book of in Kyle Edwards' Lecture 11.

```{r, echo = FALSE, warning = FALSE}
distributions <- read.csv(here("Distribution_table.csv"))

distributions <- distributions %>%
  rename("Common Ecological Data" = "Common.Ecological.Data")


distributions %>%
  dplyr::select(-Type.of.data) %>%
  gt() %>%
  tab_header(
    title = md("GLM Distributions"),
    subtitle = "Find your data type for model families, R packages, resources, and math!"
  ) %>%
  tab_source_note(md("You can find all the distributions in a package by exploring the `family` object in any `?glm*` call.")) %>%
  tab_row_group(
    group = "Data type: Binary or proportional",
    rows = 1:3
  ) %>%
  tab_row_group(
    group = "Data type: Count or abundance",
    rows = 4:11
  ) %>%
  tab_row_group(
    group = "Data type: Continuous",
    rows = 12:14
  ) %>%
  row_group_order(
    groups = c("Data type: Binary or proportional", "Data type: Count or abundance",
               "Data type: Continuous") 
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold")
    ),
    locations = cells_column_labels(
      columns = vars("Distribution", "Common Ecological Data", "Packages",
                     "Resources")
    )
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold", style = "italic")
    ),
    locations = cells_row_groups()
    )



```




From the survey results, we have a mix of datasets that *could* be fit with a basic GLM (or extensions into mixed models), including 

  + presence of many species across an environmental gradient

  + species across an environmental gradient - classic ecology, haha
  
  + CO^2^ emissions through the year from soil that received different treatments

  + abundance of fish exhibiting different social behaviors
  
  + Herbarium specimen records (collection dates, locations) ~ local climate
  
  + physiological response of individuals across size and thermal gradient

  + abundance/percent cover
  
  + species abundance and diversity across various gradients
  
  + Pathogen presence/absence, species composition and diversity
  
  + Phenological data from herbarium specimens
  
  + Condition of a species across environmental gradient and time

# C. GLMs in R 

I'm going to go through three really common GLMs in ecology (Poisson, negative binomial, and binomial). I also have several extensions for GLMs tacked on to the Extensions tab for you to explore at your leisure ( 1. zero-inflation for count data and 2. categorical predictor variables).

## Why GLM and not a basic LM?

A lot of ecological data do not fit the basic assumptions of a linear model (specifically, normal data distributions).  

Like a basic LM, GLMs do still have assumptions (heteroskedasticity, dispersion, and no zero-inflation).

We'll be using a dataset on salamander abundances in streams that are either below mountaintop removal mining sites or in control (non-mined sites) to explore some GLM approaches. Let's see why these data might be better suited for a GLM than a regular LM by looking at the frequency distribution (histogram) of the response variable (`count`) values. For an LM, the assumption is that these are normally distributed (e.g. have a nice bell curve shape).

```{r}
library(glmmTMB)
data(Salamanders)
hist(Salamanders$count)
```

The above histogram demonstrates a distribution I see in just about any of my ecological datasets that involve counts. Specifically, the data are *not* normally distributed (and there are a lot of zeros). 

Conversely, the `Sepal.Width` measurements in the `iris` dataset from last week demonstrate a beautiful normally-distributed dataset that would be perfect for a basic linear model.

```{r}
data(iris)
hist(iris$Sepal.Width)
```

## R Packages for GLMs

```{r}
library(MASS) #glm.nb for negative binomial models
library(glmmTMB) #Salamanders dataset and lots of families
library(lme4) #grouseticks dataset and mixed model functionality
library(DHARMa) #model diagnostics
library(effects) #what do my marginal effects look like?
library(performance) #binomial model diagnostics
library(emmeans) #post hoc for categorical predictors
```

LMs, GLMs, and their extensions (e.g. mixed models) are used a TON in ecology and other fields so there are lots of R packages for regression, including some base packages and some more fancy ones. 

**Ana uses:**
`stats` (pre-loaded in R), `MASS` for the `glm.nb` function for negative binomial data, and `glmmTMB` for most GLM models and mixed models

**Tatum uses:**
`stat` and `MASS` as above, plus `stepAIC` in `boot` to hone in on a best model quickly

There are also lots of packages for diagnosing model fits for GLMs and their extensions.

**Ana uses:**
`DHARMa` for all the "do my data fit my model" questions, `performance` for "do my data fit my model" questions for binomial models, `effects` for looking at what the marginal effects are of the model (e.g. what is the relationship in my data?), and `emmeans` for models with categorical predictors (covered later)

**Tatum uses:**
simulation and the `boot` package's `glm.diag` functions to validate the model

### Model-fitting packages

[`stats`](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/00Index.html)

[`MASS`](https://cran.r-project.org/web/packages/MASS/index.html)

[`glmmTMB`](https://cran.r-project.org/web/packages/glmmTMB/index.html)

[`boot`](https://cran.r-project.org/web/packages/boot/index.html)

### Model diagnostics packages

[`DHARMa`](https://cran.r-project.org/web/packages/DHARMa/index.html)

[`performance`](https://cran.r-project.org/web/packages/performance/index.html)

[`effects`](https://cran.r-project.org/web/packages/effects/index.html)

[`emmeans`](https://cran.r-project.org/web/packages/emmeans/index.html)

[`boot`](https://cran.r-project.org/web/packages/boot/index.html)

## The GLM process

The process of fitting a GLM includes an iterative process of steps:

1. **Determine a model structure** based on experimental design (what is the effect of x (and potentially z, a, and b) on y (and potentially c and d)?)

    + What is the effect of water temperature and elevation on the abundance of caddisfly larvae?
  
    + What is the effect of habitat patch size and productivity on the presence or absence of spiders?
  
2. Do some **model selection process** to figure out what is a best model (teaser for next week, not part of today's discussion!)

3. **Do my data meet model assumptions**, and if not, how do I fix this? (Ana: most of my time in statistics is spent on this step)

```{r, echo=FALSE}
knitr::include_graphics(here("GLM_process.jpg"))
```


*Ana's words of encouragement: I follow an approach I learned from the Zuur book when developing and fitting models to my data. Start a priori with a full model I want to test, some knowledge of the type of family it should fit (for counts, likely Poisson, negative binomial, or some derivative), and try to remember the ecological reasons for why I'm doing my statistics. Not only does this avoid finding significance just because I've thrown in everything and the kitchen sink, but it also helps me explain my statistics to myself and to others who might not be statisticians first. Once I dove in to model selecting, I realized that everyone on Stack Overflow has their own strong and differing opinions about the "right" way, which made me think there isn't a "right" way and it's more important to be able to justify what I did by being consistent and transparent with my process.*

## Poisson GLM: Count data

Now the part we've all been waiting for - let's fit one of these GLMs!

We'll be using a dataset of salamander abundances from a paper on the effects of mountaintop removal on salamanders in streams ([Price et al. 2015](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2664.12585)). The dataset is in the glmmTMB package.

```{r}
data(Salamanders) #from glmmTMB
```

This dataset has 644 observations of 9 variables:

```{r}
str(Salamanders)
```

**site**: name of a location where repeated samples were taken

**mined**: factor indicating whether the site was affected by mountain top removal coal mining

**cover**: amount of cover objects in the stream (scaled)

**sample**: repeated sample

**DOP**: Days since precipitation (scaled)

**Wtemp**: water temperature (scaled)

**DOY**: day of year (scaled)

**spp**: abbreviated species name, possibly also life stage

**count**: number of salamanders observed

### Going back to the three steps we need to fit a GLM to our data:

1. What is our question (e.g. what is the effect of x on y?)

2. What is the best model? (not addressed in this presentation)

3. Do my data meet model assumptions, and how do I fix this if not?

### 1. Poisson: What is the question?

Let's say that this study was part of a project looking at how stream variables influenced salamander presence or abundance (we address [categorical predictors](#categorical) in the Extensions  and will revisit the mined vs. not mined question there and how to approach that with a GLM). Our question with a continuous predictor might be:

  + What are the effects of cover and water temperature on salamander abundance?
  
```{r}
Salamanders %>%
  gather(-site, -mined, -sample, -DOP, -DOY, -spp, -count, key = "var", value = "value") %>%
  ggplot(aes(x = value, y = count)) +
  geom_point() +
  geom_smooth(method = "lm", se =F) +
  facet_wrap(~ var, scales = "free") +
  theme_bw()
```

Based on this graph, *maybe* there is some positive influence of cover on salamander abundance and some negative influence of water temperature. (To answer this question conclusively and correctly, we'd need to do step 2. what is the *best* model, but stay tuned, that's coming up next week!)

The same way we fit an LM in the last session, we can call a GLM, but now using a GLM formula. Again, from above, we have abundance (count) data with a left-skewed distribution (not normal), so we will be starting with a Poisson distribution and tinkering with fixes on that model family (e.g. negative binomial).

```{r}
model <- glm(count ~ cover + Wtemp,
    data = Salamanders,
    family = "poisson")
```

We can look at the model summary, which looks really similar to the basic regression summary. 

```{r}
summary(model)
```

Based on this model, maybe there is an effect of cover on salamander abundance. 

### 2. Poisson: What is the "best" model (Next week!)

Let's pretend this is our best model, which means we can go on to step 3. 

### 3. Poisson: Do my data fit the model assumptions?

Now that we have our model that we want to report in our paper, we need some way to say whether our data actually meet the assumptions of this model. You can approach these in a similar way to the LM model tests of last week, but there are several extensions here (dispersion and zero-inflation) AND some reasons as you get to more complicated models (e.g. mixed models) as to why you might want something that gives you some confidence interval (e.g. p-value) to whether your visual assessments of your data warrant revisiting your model.

I use the `DHARMa` package for this in all my linear models (mixed and non-mixed). `DHARMa` simulates a bunch of sets of residuals from each observations based on the fitted model, including the probability of those values given the data. The outputs are AWESOME diagnostics that look really similar to the qqplots and residual plots from basic model diagnostics, except now with some confidence that the data fit model assumptions tacked on (and the ability to determine overdispersion and zero-inflation).

This is a very simplified explanation of the `DHARMa` package, but they have a great [tutorial](https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html) with more in-depth explanations and lots more functions from the package. 

First, we'll simulate our batches of residuals based on our fitted model:

```{r}
simulationOutput <- simulateResiduals(fittedModel = model, plot = T)
```

YIKES. We've got some issues with model assumptions. This shape for a qqplot is definitely evidence of some potential overdispersion, but we can test that explicitly in the `DHARMa` package using the `testDispersion()` function.

```{r}
testDispersion(simulationOutput)
```

The `testDispersion()` function gives us a histogram of simulated *expected* values, and then a red line indicating our *observed* dispersion in our actual data. Additionally, this function performs a statistical test of our dispersion with the null hypothesis being "We do not have overdispersion". Our very low p-value indicates that our dispersion value is not very likely to come from the distribution of expected dispersion values for our model. Simply: **we have overdispersion**.

### Poisson: Common fixes for models that don't meet assumptions

Overdispersion is a really common problem for count data and the good news is that there are some pretty easy fixes. *(A place where opinions on the order in which you apply fixes deviates, but I'll show you mine. Kyle Edwards and the Zuur book both have great workflows for this, which I based mine off as well. You can also find my [flowchart for model selection](#flowchart) in the Extensions tab)*.

The fixes used can depend on your data and what your model looks like in the first place. There are some simple math-related reasons based on model distributions for why overdispersion could be occurring and there are also some more practical reasons based on the variables we put into (or didn't put into) the model. 

1. Did I include all the relevant variables?

    + Are there other fixed effects that may be needed in my model?
    
    + (Not covered today, and maybe a problem with this dataset: is there a need for grouping variables (random effects and mixed models)?)

2. Do my data actually fit a Poisson distribution? (lots of opinions and approaches to address this point and Tatum and Ana differ in their approaches)

    + Ana's approach: 1) refit with a negative binomial model, 2) add a zero-inflation term, 3) think about data transformations. (some other useful overdispersion tips, specifically for GLMMs, but useful for GLMs too, on [Ben Bolker's GLMM FAQ page](https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html))
    
    + Tatum's approach: 1) refit with a negative binomial or really any other function that has correct support (see table, may require transformation), 2) add a zero-inflation term or choose a hurdle model

## Negative binomial GLM: overdispersed count data

Taking Ana's approach, let's start by refitting our data to a negative binomial distribution, which we can do with the `glm.nb` function from the `MASS` package. 

This means we're returning to Step 1 via Step 4A in our GLM process flowchart:

```{r, echo =FALSE}
knitr::include_graphics(here("GLM_process.jpg"))
```

### 1. NB: What is the question?

In this case, the ecological question stays the same, we're just using a different model family to better account for model assumptions. 

```{r}
nb.model <- glm.nb(count ~ cover + Wtemp,
                   data = Salamanders)
```

Looking at the summary of this model, it looks like cover is still important, but the model coefficients have changed. 

```{r}
summary(nb.model)
```

(Just as a reminder, the summary for the Poisson model): 

```{r}
summary(model)
```

### 2. NB: What is the "best" model (Next week!) 

Again, let's say we went through the step 2 model selection process and this came out as the best model.

### 3. NB: Do my data fit the model assumptions?

Let's see how the model and data do in terms of model assumptions: 

```{r}
simulationOutput <- simulateResiduals(fittedModel = nb.model, plot = T)
```

It looks like we've fixed the overdispersion problem, but may still have some issues with this dataset based on the residuals plot. Let's look at the dispersion problem specifically:

```{r}
testDispersion(simulationOutput)
```

We have fixed the overdispersion! However, based on the output from this model, it still looks like we have some patterns in our residuals. I'm not surprised about this, given that it's an example dataset in a mixed model package and so likely we are having more of a practical problem with missing effects in this model. (Maybe once we learn mixed models we can revisit?)

### Count data wrap-up: a quick visualization

I'm a visual person, so at this point I always want to know what my model is actually telling me ecologically (e.g. what is the effect of cover??). I do quick diagnostics using the `effects` package and the `allEffects` function. This is just a line graph showing the marginal change in count for this model given a change in each of the predictors, while accounting for everything else in the model. You can get similar and more complex marginal effects plots with the `ggeffects` package, but I haven't played with it much. I wouldn't put this into my final paper, but it helps me to stay grounded in the ecology when I get lost in the R and statistics world.

```{r}
plot(allEffects(nb.model))
```

## Binomial GLM: Presence-absence data

Now let's say we were actually interested in just whether we find salamanders or not, not their actual abundances in each stream. This means we have a binary response of presence-absence and want to know whether presence is predicted by cover or water temperature. We can convert the count data to a binary variable of `presence`:

```{r}
Salamanders <- Salamanders %>%
  mutate(presence = ifelse(count > 0, 1, 0))
```

And then look at whether our two predictors (stream cover and water temperature) predict presence. 

```{r}
Salamanders %>%
  gather(-site, -mined, -sample, -DOP, -DOY, -spp, -count, -presence, key = "var", value = "value") %>%
  ggplot(aes(x = value, y = presence)) +
  geom_point() +
  geom_smooth(method = "lm", se =F) +
  facet_wrap(~ var, scales = "free") +
  theme_bw()
```

This is kind of a hard graph to visualize because of the binary response variable, but visually it does look like there might be more 1's as cover increases and maybe more zeros as water temperature increases. 

### 1. Binomial: What is the question

Our question here is really similar to the question above, except now we want to know whether stream cover and water temperature predict the *presence* of salamanders, rather than their abundance. Now that we have a binary presence-absence response variable, we will be using the binomial distribution to fit our data. You can run a binomial model by just changing the `family =` argument in the `glm()` function. 

```{r}
bi.model <- glm(presence ~ cover + Wtemp,
                data = Salamanders,
                family = binomial)
```

Our model summary is really similar to before and suggests some evidence that stream cover is, indeed, predictive of whether we see salamanders in streams or not. 

```{r}
summary(bi.model)
```

### 2. Binomial: What is the "best" model (Next week!) 

Again skipping this step for now!

### 3. Binomial: Does my data fit the model assumptions

With this model, we can again use `DHARMa` to test model assumptions and we can also use the `binned_residuals()` function in the `performance` package, which is specifically designed for binomial distributions.

```{r}
simulationOutput <- simulateResiduals(fittedModel = bi.model, plot = T)
```


According to this, this model actually performs pretty well. 

The residuals for a binomial model always look pretty funky:

```{r}
plot(residuals(bi.model))
```

So we can use the   `binned_residuals` function to tell how well our model is doing, which is... ok, but not great.

From the vignette for the `performance` package: "Binned residual plots are achieved by “dividing the data into categories (bins) based on their fitted values, and then plotting the average residual versus the average fitted value for each bin.” (Gelman,Hill 2007: 97). If the model were true, one would expect about 95% of the residuals to fall inside
the error bounds."

```{r}
binned_residuals(bi.model)
```

Based on these residuals, our data is *ok*, but not great at fitting model assumptions (95% of residuals). Again, this could be because of the practical or math reasons outlined above from the Poisson and negative binomial models:

1. Did I include the right variables in my model?

    + Are there other fixed effects that may be needed in my model?
    
    + (Not covered today, and maybe a problem with this dataset: is there a need for grouping variables (random effects and mixed models)?)

2. Do my data actually fit a binomial distribution? 

    + variable transformations or quasi-binomial distribution
    
### Presence data wrap-up: a quick visualization

We can do another quick diagnostic visualization to ground ourselves here as well!

```{r}
plot(allEffects(bi.model))
```

# D. Extensions

There are lots of kinds of ecological data and so many model distributions for asking statistical questions about them. It's impossible to cover them all in an hour!

In this section, I'm going to go over a couple other really common types of data for GLMs, including **zero-inflated count data** and models with **categorical predictors**. 

In addition, I've added a [flowchart](#flowchart) I use for fitting, choosing, and diagnosing GLMs and GLMMs for count data. It's a little bit of a teaser for the coming weeks, but hopefully it can be a resource!

## Extension 1: Zero-inflated count data

As you may know from your own datasets, ecological data of counts often have a lot of zeros. Sometimes, these datasets have so many zeros that neither Poisson or negative binomial models will work. There are a set of models called "Zero-inflated" models (can be either Poisson or negative binomial), which are basically that - models that can fit data that have an "inflated" number of zeros. There are tons of resources on this, and I won't cover it all here, just providing a practical worked example. (there are also two types of zero-inflated models that I won't go into, but have to do with where the zeros are coming from, not going to try to have an exhaustive example here, but look into it if this is a problem for you!)

**Zuur chapter 11 is a go-to resource to get started!**

[Another set of worked examples](https://fukamilab.github.io/BIO202/04-C-zero-data.html#key_points)

[Books](https://highstat.com/index.php/beginner-s-guide-to-zero-inflated-models)

[More books](https://highstat.com/index.php/zero-inflated-models-and-generalized-linear-mixed-models-with-r)

[GOOGLE](https://www.google.com/search?sxsrf=ALeKk00BAogDZPbJ5yHQg810CFuTJ3HEgA%3A1595002818410&ei=ws8RX83OGMe0tAaxl474Aw&q=zero+inflated+models+ecology&oq=zero+inflated+models+ecology&gs_lcp=CgZwc3ktYWIQAzIFCAAQzQIyBQgAEM0CMgUIABDNAjIFCAAQzQIyBQgAEM0COgQIABBDOgYIABAHEB46BwgAEBQQhwI6AggAOgYIABAWEB46CAgAEBYQChAeOgUIIRCgAToHCCEQChCgAVDpJVjlNGC1NmgAcAB4AIAB3AGIAbsIkgEFMi42LjGYAQCgAQGqAQdnd3Mtd2l6&sclient=psy-ab&ved=0ahUKEwjNt6DD2NTqAhVHGs0KHbGLAz8Q4dUDCAw&uact=5)

Let's play with a different dataset from the lme4 package on the number of ticks observed in grouse chicks in nests in different years, elevations, and locations. 

```{r}
data(grouseticks)
str(grouseticks)
```

**INDEX**: (factor) chick number (observation level)

**TICKS**: number of ticks sampled

**BROOD**: (factor) brood number

**HEIGHT**: height above sea level (meters)

**YEAR**: year (-1900)

**LOCATION**: (factor) geographic location code

**cHEIGHT**: centered height, derived from HEIGHT

### 1. Zero-inflated count data: What is the question?

Let's say our question was whether elevation has an effect on tick abundance in grouse chicks, maybe because lower elevation sites have a larger temperature window of tick activity.

```{r}
ggplot(grouseticks, aes(x = HEIGHT, y = TICKS)) +
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  theme_bw()
```
It does look like there is some effect of elevation on tick abundance, and it *does* seem to be negative (e.g. higher elevation = lower tick abundance).

Like the previous dataset on salamanders, there are a lot of zeros in this dataset

```{r}
hist(grouseticks$TICKS)
```

```{r}
grouseticks %>%
  filter(TICKS == 0) %>%
  summarise(count = n(), total = 403, proportion = count/403)
```

Out of 403 observations, 126 observations are zeros (31%). That's a lot! 

Again, we will start with fitting a normal Poisson model: 

```{r}
ticks_poisson <- glm(TICKS ~ HEIGHT,
                   data = grouseticks,
                   family = "poisson")
```

### 2. Zero-inflated count data: What is the "best" model? (Skipping again)

If this was our best model (skipping step 2 again), we can assess the residuals: 

### 3. Zero-inflated count data: Does my data fit the model assumptions?

```{r}
simulationOutput <- simulateResiduals(fittedModel = ticks_poisson, plot = T)
```

And test for overdispersion again:

```{r}
testDispersion(ticks_poisson)
```

Again, we have overdispersion. If it was me, I would start by trying to fit a negative binomial model (as before). Even with this number of zeros, often re-fitting with a negative binomial model will fix a lot of issues with zeros. However, for the sake of learning, let's say that we can't fit a negative binomial model to these data, or that it doesn't fit our zero inflation problems. 

**How do we determine we have zero inflation issues, you ask?** The `DHARMa` package has another useful function called `testZeroInflation()` that I always throw into my model diagnostics for count data.

```{r}
testZeroInflation(ticks_poisson)
```

This output operates a lot like the `testDispersion()` function output. Again, `DHARMa` has created some simulated expected values for our model, and we see that our distribution has way more zeros than would be predicted by a simulated data distribution based on our model. 

### 1.a. Zero-inflated count data: What is the question?


Again, we have the same question, we just need to fit a different model family that incorporates zero inflation. There are several packages that will let you fit a zero-inflated model (`pscl`, `glmmTMB`, `ZIM`). You can find a tutorial based on `pscl` at [this website](https://fukamilab.github.io/BIO202/04-C-zero-data.html#key_points). I use `glmmTMB` because it has a lot of flexibility and lets me extend to mixed models really easily. It is an actively-developing package that many of the pre-eminent mixed model people in ecology swear by. 

In `glmmTMB`, the function to call a glm is `glmmTMB()` and we can add a zero-inflation term with an added argument (`ziformula = 1`). There are more complicated ways to call a zero-inflated formula, but this is the basic one.([more here](https://cran.r-project.org/web/packages/glmmTMB/vignettes/glmmTMB.pdf))

Referring again to our flowchart for GLMs, we're doing Step 1 via Step 4A again, except this time we're going to fit a zero-inflated model rather than a negative binomial model to see if we can fix our model assumption problems:

```{r, echo = FALSE}
knitr::include_graphics(here("GLM_process.jpg"))
```

```{r}
ticks_zi <- glmmTMB(TICKS ~ HEIGHT,
                   data = grouseticks,
                   ziformula = ~1,
                   family = "poisson")
```


### 2.a. Zero-inflated count data: What is the "best" model?

Skip!

### 3.a. Zero-inflated count data: Do my data meet model assumptions?

Repeating our diagnostics:

```{r}
simulationOutput <- simulateResiduals(fittedModel = ticks_zi, plot = T)
```

This is **NOT** a good model fit! But, let's see if we fixed the zero-inflation by including a zero inflation term in our model:

```{r}
testZeroInflation(ticks_zi)
```

Yes we have! However, we still need to consider all the math and practical reasons why this model isn't good (do we need to add variables, do we need a different distribution, do we need to transform?).

## Extension 2: Categorical fixed effects {#categorical}

GLMs can sometimes look suspiciously like an ANOVA, which isn't surprising and makes GLMs really versitile!

Let's revisit the example of the salamanders in streams that either were or weren't below mountaintop removal sites. In this example, if we want to know whether mining has an effect on salamander abundance, we are dealing with a categorical fixed effect (mined vs. unmined). We can approach this really similarly to any other GLM and can also get diagnostics that look suspiciously similar to ANOVA diagnostics. Let's do it:

### 1. Categorical fixed effect, count response: what is my question?

Again, we have count data, so we're going to be playing with Poisson or negative binomial models with this one. Our question is now **What is the effect of presence of mountaintop mining on the abundance of salamanders in streams?"**

In this situation, it might be more intuitive to look at our data as a boxplot:

```{r}
ggplot(Salamanders, aes(x = mined, y = count)) +
  geom_boxplot() +
  theme_bw()
```

But we could also coerce our yes/no predictor into a continuous-type variable and visualize it as a line graph, setting the "no" level to "1", and the "yes" level to "2". 

```{r}
Salamanders %>%
  mutate(mine_line = ifelse(mined == "no", 1, 2)) %>%
           ggplot(aes(x = mine_line, y = count)) +
           geom_point() +
           geom_smooth(method = "lm", se = FALSE) +
           theme_bw()
```
In both of these graphs, it looks like mining may have a positive effect on salamander abundance. 

In our model, the fixed effect will be `mined` (a binary yes/no) and our response will be `count` from the `Salamanders` dataset:

```{r}
cat_poisson <- glm(count ~ mined, 
                   data = Salamanders,
                   family = "poisson")
```

We can look at our model summary again to see that the effect of mining does seem to be important for salamander abundance.

```{r}
summary(cat_poisson)
```

### 2. Categorical fixed effect, count response: what is the "best" model?

Covered next week

### 3. Categorical fixed effect, count response: do data meet assumptions?

This probably seems repetitive by now - but we can also use `DHARMa` for this kind of model.

```{r}
simulationOutput <- simulateResiduals(fittedModel = cat_poisson, plot = T)
```

This model also has so many of the beautiful model assumption failures we're getting good at assessing. 

```{r}
testDispersion(simulationOutput)
```

```{r}
testZeroInflation(simulationOutput)
```

So we could approach it like we've been approaching any other model when it comes to fixing this!

**On your own**: How would you attempt to fix some of these model assumption failures?

#### Catagorical predictor wrap-up: post-hoc and visualizations

In this example, our predictor had two categories, and so we can report model results (including the p-value) for the between-group differences (ala ANOVA) from the `summary()` for the model. However, if you had a categorical variables with more than two levels, there are some cool ways to do pair-wise comparisons between those levels (for example, if I had "full mountaintop removal", "partial mountaintop removal", and "no mountaintop removal" mining categories for the Salamander dataset). 

Again, at this point I always like to do a quick visual of my data, which I can still do with the `allEffects` call:

```{r}
plot(allEffects(cat_poisson))
```

If I had more than two levels for my predictor, I could use the `emmeans` package and function to determine the pair-wise differences between groups. 

```{r}
em <- emmeans(cat_poisson, "mined")
```

The `emmeans()` function calculates the marginal means (mean of a group given all the other groupings in the model) based on a specified predictor (here, "mined"): 

```{r}
em
```

and then you can compare these means to each other:

```{r}
pairs(em)
```


## Flowchart for GLM and GLMM model selection for count data {#flowchart}

Here's a flow chart of my complete model selection process and troubleshooting for count data (for GLMM, but can easily be used for GLM as well)

```{r, echo = FALSE}
knitr::include_graphics(here("model-selection.jpg"))
```
